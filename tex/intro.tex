\section{Введение}
\subsection{О чем этот текст}
Основная идея данного текста --- дать широкую картину экосистемы *nix мира, показать как устроены некоторые вещи и дать возможность комфортно себя чувствовать нетехническим специалистам в относительно технических дискуссиях. Я не собираюсь углубляться в алгоритмы или детали реализации, цель, скорее --- добиться достаточно понимания, чтобы не теряться.

\subsection{1960-е}
В 1960-х годах ЭВМ стали массово появляться в коммерческих организациях и университетах. На тот момент ЭВМ --- это достаточно объемный агрегат, за котором работает много пользователей. Машинное время дорого, устройства ввода/вывода и связи медленны, поэтому отнюдь не все пользователи работают в интерактивном режиме --- многие это делают пакетным образом, задавая наборы команд заранее и получая результаты с ощутимой задержкой. Таким образом, достаточно штатной ситуаций где-то до микрокомпьютерной революции 1980-х является следующая:
\begin{itemize}
  \item В одной ЭВМ установлена одна операционная система (OS);
  \item В одной OS одновременно работает множество пользователей;
  \item Пользователи работают удаленно, не имея физического доступа к ЭВМ;
  \item Четко выражена роль пользователей имеющих административные привелегии и тех, у кого их нет;
  \item Использование пользователями ресурсов четко контролируется;
  \item Машинное время, память и диски дороги.
\end{itemize}

При этом, большинство OS на тот момент были написаны на ассемблере, что не позволяло их портировать на другие архитектуры или ЭВМ других производителей. OS обычно писались производителями самих ЭВМ и уровень совместимости их между собой был весьма низкий. Если техника от IBM в общем случае обладала достаточно похожими версиями OS, то сказать это о двух произвольных машинах от двух произвольных производителей в общем случае было нельзя.

\subsection{Томпсон и Ричи}
Кеннет Томпсон и Деннис Ричи в это время работают в Bell Labs --- структурном подразделении AT\&T, занимающимся разработками новых технологий. Бардак с операционными системами написанными на ассемблере их не устраивает, и они решают написать новую систему.

Параллельно с разработкой OS становится понятно, что существующих языков программирования для реализации замысла в желаемом виде не достаточно.
Разработав ранее язык B и взяв его за основу, пара создает язык C и операционную систему UNIX.

Язык C оказывается весьма успешен и быстро портируется на многие архитектуры. Написанная в основном на нем операционная система UNIX требует небольших и заранее понятных изменений на ассемблере для портирования на новые архитектуры. Простота портирования UNIX позволила ему относительно быстро занять ведущую роль среди OS для коммерческого и академического применения.

\subsection{Язык C}
Язык C является компактным процедурным языком. Словарь его можно запомнить достаточно быстро; однако несмотря на небольшое количество зарезервированных слов, язык позволяет разработчику эффективно реализовывать любые алгоритмы. На данный момент C обычно используется в основном для системного программирования.

В эпоху своего создания, C позволил программистам писать не на ассемблере, а на гораздо более дружелюбном языке. При необходимости, код на C может вызывать инструкции ассемблера. С, таким образом, является гибким инструментом для специализированных задач. Гибкость эта, однако, требует высокого уровня понимания того, а что именно делает код и какая перед ним стоит задача --- \enquote{выстрелить в свою ногу} в C неимоверно просто.

Концептуально похожие моменты присутствуют и в OS UNIX.

\subsection{UNIX}
К концу 1970-x годов OS UNIX становится достаточно похожей на текущие доступные нам версии. К этому моменту формируется несколько основных концепций, определяющие мировоззрение в среде UNIX:
\begin{itemize}
  \item Каждая программа должна делать что-то одно и делать это хорошо;
  \item Вывод одной программы может быть вводом другой;
  \item Текстовые строки --- базовый формат коммуникаций;
  \item Пользователь должен иметь возможность работать в неинтерактивном режиме;
  \item Ручной неквалифицированный труд нужно заменять автоматизацией.
\end{itemize}

На практике эти подходы означают, что присутствует \hyperref[sec:commands]{ядро команд}, позволяющих реализовать широкий спектр задач прямо в OS. Кроме того, изначальная нацеленность на неинтерактивные режимы работы пользователей создало почву для \hyperref[sec:shell_scripting]{создания скриптов} еще больше расширяющих возможности того, что можно сделать прямо в OS.

Распространение нового программного обеспечения в этой парадигме осуществляется путем распространения исходных кодов и дальнейшей сборки и компиляции бинарных файлов на конкретной системе. Наличие исходных кодов предполагает, что разработчик может полностью контролировать и осознавать, что именно делает ПО.

Графические пользовательские интерфейсы во время разработки UNIX встречались достаточно редко. Операционная система позволяет работать с терминальной консоли и графический пользовательский интерфейс \hyperref[sec:Xserver]{реализован отдельно}.

\subsection{Лицензирование}
В 1980-е годы появляются концепции прав собственности на ПО, отличных от авторских прав. На практике это приводит к фрагментации версий OS UNIX на свободные (в основном на основе BSD), и проприетарные решения. Количество разных версий UNIX, восходящих корнями к разным общим веткам кода весьма велико и есть, как правило, либо следствия наличия отдельных производителей аппаратного обеспечения (Sun Solaris, MacOS), либо наличия конкретных задач (NetBSD, OpenBSD).

Существуют разные виды свободного ПО, в зависимости от способа лицензирования и философского подхода авторов.

\subsubsection{GNU}
\enquote{GNU --- GNU is not UNIX} --- инициатива GNU больше всего известна личностью Ричарда Столлмана, являющегося одним из наиболее известных апологетом идей свободного ПО. GNU занимает весьма последовательную позицию касательно невключения проприетарного кода и не использования бинарных файлов, исходных кодов которых не предоставлено (часто это происходит с драйверами видеокарт). В общем случае, GNU версии программного обеспечения точно являются свободными и соответствуют стандартам (или имеют режимы работы, соответствующие стандартам).

\subsection{POSIX}
POSIX является семейством стандартов описывающих то, что должна делать операционная система. В силу того, что на момент начала написания UNIX был основной OS, поддерживающей аппаратное обеспечение разных производителей, во многом POSIX стандарт опирается на UNIX.

Большинство *nix OS поддерживают POSIX в той или иной степени. Часто поддерживается более широкий набор параметров и свойств, чем требуется стандартом.

Набор ПО, поддерживающий POSIX может работать как OS и будет во многом совместим с существующими *nix системами.

\subsection{Linux}
В начале 1990-х Линус Торвальдс в Финляднии понял, что работа с существующими версиями UNIX неудобна для его целей и решил сделать набор утилит, которые позволили бы ему проще работать с той версией UNIX (Minix), что у него была под руками. Эта работа вылилась в деятельность по реализации большой части POSIX функционала и положила началу создания ядра Linux.

Linux не является какой-то одной операционной системой --- присутствует некое общее ядро, на которое каждая группа разработчиков добавляет то, что считает нужным. Linux является свободным ПО, но при этом не всегда строго соответствует нормам GNU, при том, что может быть близок к ним.

\subsection{MacOS, iOS}
MacOS и iOS построены на Darwin, который содержит в себе элементы UNIX. Исходные коды Darwin являются открытыми. Исходные коды MacOS и iOS не доступны. Они включаются в себя как Darwin, так и проприетарные компоненты. MacOS и iOS не являются POSIX сертифицированными OS, но на практике POSIX совместимы.

\subsection{OpenBSD}
OpenBSD является версией UNIX нацеленной на безопасность. Весь код OS многократно проверяется. Как часть OpenBSD так же поддерживается набор инструментов openssh, который используется в других OS. OpenBSD часто используется в качестве OS, доступной из вне.

\newpage
